/*Type definitions for SurveyJS PDF library v1.8.36
Copyright (c) 2015-2021 Devsoft Baltic OÜ  - http://surveyjs.io/
Definitions by: Devsoft Baltic OÜ <https://github.com/surveyjs/>
*/
// Dependencies for this module:
//   ../../../../survey-core

import { SurveyModel, Event } from 'survey-core';
import { IQuestion, Question, QuestionRatingModel, QuestionFileModel, LocalizableString } from 'survey-core';
import { QuestionBooleanModel } from 'survey-core';
import { ItemValue, QuestionCheckboxModel } from 'survey-core';
import { QuestionCommentModel } from 'survey-core';
import { QuestionDropdownModel } from 'survey-core';
import { QuestionExpressionModel } from 'survey-core';
import { QuestionHtmlModel } from 'survey-core';
import { QuestionImageModel } from 'survey-core';
import { QuestionImagePickerModel } from 'survey-core';
import { QuestionPanelDynamicModel } from 'survey-core';
import { QuestionRadiogroupModel } from 'survey-core';
import { QuestionCheckboxBase } from 'survey-core';
import { QuestionSignaturePadModel } from 'survey-core';
import { QuestionTextModel } from 'survey-core';
import { PanelModel } from 'survey-core';
import { QuestionMatrixModel, MatrixRowModel } from 'survey-core';
import { QuestionMatrixDropdownModelBase } from 'survey-core';
import { QuestionMultipleTextModel } from 'survey-core';
import { MultipleTextItemModel } from 'survey-core';
import { PageModel } from 'survey-core';

/**
    * SurveyPDF object contains options, events and methods to export PDF
    */
export declare class SurveyPDF extends SurveyModel {
        options: IDocOptions;
        constructor(jsonObject: any, options?: IDocOptions);
        /**
            * You have right to set this property to true if you have bought the commercial licence only.
            * It will remove the text about non-commerical usage on the top of the document.
            * Setting this property true without having a commercial licence is illegal
            */
        get haveCommercialLicense(): boolean;
        set haveCommercialLicense(val: boolean);
        /**
            * The event in fired for every rendered page
            * @param survey SurveyPDF object that fires the event
            * @param canvas DrawCanvas object that you may use it to draw text and images in the page header
            */
        onRenderHeader: Event<(survey: SurveyPDF, canvas: DrawCanvas) => any, any>;
        /**
            * The event in fired for every rendered page
            * @param survey SurveyPDF object that fires the event
            * @param canvas DrawCanvas object that you may use it to draw text and images in the page footer
            */
        onRenderFooter: Event<(survey: SurveyPDF, canvas: DrawCanvas) => any, any>;
        /**
            * The event in fired for every rendered question
            * @param survey SurveyPDF object that fires the event
            * @param options AdornersOptions object that have options to custom render the question
            */
        onRenderQuestion: EventAsync<(survey: SurveyPDF, options: AdornersOptions) => any, any>;
        /**
            * The event in fired for every rendered panel
            * @param survey SurveyPDF object that fires the event
            * @param options AdornersPanelOptions object that have options to custom render the panel
            */
        onRenderPanel: EventAsync<(survey: SurveyPDF, options: AdornersPanelOptions) => any, any>;
        /**
            * The event in fired for every rendered page
            * @param survey SurveyPDF object that fires the event
            * @param options AdornersPageOptions object that have options to custom render the page
            */
        onRenderPage: EventAsync<(survey: SurveyPDF, options: AdornersPageOptions) => any, any>;
        /**
            * Call save method of surveyPDF object to download file in browser. This is asynchronous method
            * @param fileName optional filename parameter
            */
        save(fileName?: string): Promise<any>;
        /**
            * Call raw method of surveyPDF to get PDF document as string object. This is asynchronous method
            * @param type omit to get raw string, or pass "blob", "bloburl" or "dataurlstring"
            */
        raw(type?: string): Promise<string>;
}

export declare class SurveyHelper {
    static readonly EPSILON: number;
    static readonly TITLE_SURVEY_FONT_SIZE_SCALE: number;
    static readonly TITLE_PANEL_FONT_SIZE_SCALE: number;
    static readonly DESCRIPTION_FONT_SIZE_SCALE: number;
    static readonly OTHER_ROWS_COUNT: number;
    static readonly RATING_MIN_WIDTH: number;
    static readonly RATING_MIN_HEIGHT: number;
    static readonly RATING_COLUMN_WIDTH: number;
    static readonly MATRIX_COLUMN_WIDTH: number;
    static readonly IMAGEPICKER_COUNT: number;
    static readonly IMAGEPICKER_RATIO: number;
    static readonly MULTIPLETEXT_TEXT_PERS: number;
    static readonly HTML_TAIL_TEXT_SCALE: number;
    static readonly SELECT_ITEM_FLAT_SCALE: number;
    static readonly GAP_BETWEEN_ROWS: number;
    static readonly GAP_BETWEEN_COLUMNS: number;
    static readonly GAP_BETWEEN_ITEM_TEXT: number;
    static readonly BORDER_SCALE: number;
    static readonly VISIBLE_BORDER_SCALE: number;
    static readonly UNVISIBLE_BORDER_SCALE: number;
    static readonly RADIUS_SCALE: number;
    static readonly TITLE_FONT_SCALE: number;
    static readonly VALUE_READONLY_PADDING_SCALE: number;
    static readonly HTML_TO_IMAGE_QUALITY: number;
    static readonly FORM_BORDER_COLOR: string;
    static readonly TEXT_COLOR: string;
    static readonly BACKGROUND_COLOR: string;
    static readonly TITLE_LOCATION_MATRIX: string;
    static readonly STANDARD_FONT: string;
    static readonly CUSTOM_FONT_ENCODING: string;
    static parseWidth(width: string, maxWidth: number, columnsCount?: number): number;
    static pxToPt(value: number): number;
    static mergeRects(...rects: IRect[]): IRect;
    static createPoint(rect: IRect, isLeft?: boolean, isTop?: boolean): IPoint;
    static createRect(point: IPoint, width: number, height: number): IRect;
    static createHeaderRect(controller: DocController): IRect;
    static createFooterRect(controller: DocController): IRect;
    static createDivBlock(element: string, controller: DocController): string;
    static generateCssTextRule(fontSize: number, fontStyle: string, fontName: string): string;
    static splitHtmlRect(controller: DocController, htmlBrick: IPdfBrick): IPdfBrick;
    static createPlainTextFlat<T extends IPdfBrick>(point: IPoint, question: IQuestion, controller: DocController, text: string, fabric: new (question: IQuestion, controller: DocController, rect: IRect, text: string) => T): CompositeBrick;
    static createTextFlat<T extends IPdfBrick>(point: IPoint, question: IQuestion, controller: DocController, text: string | LocalizableString, fabric: new (question: IQuestion, controller: DocController, rect: IRect, text: string) => T): Promise<IPdfBrick>;
    static createHTMLFlat(point: IPoint, question: Question, controller: DocController, html: string): Promise<IPdfBrick>;
    static htmlToXml(html: string): string;
    static htmlToImage(html: string, width: number, controller: DocController): Promise<{
        url: string;
        aspect: number;
    }>;
    static createBoldTextFlat(point: IPoint, question: Question, controller: DocController, text: string | LocalizableString): Promise<IPdfBrick>;
    static createTitleFlat(point: IPoint, question: Question, controller: DocController): Promise<IPdfBrick>;
    static createTitleSurveyFlat(point: IPoint, controller: DocController, text: string | LocalizableString): Promise<IPdfBrick>;
    static createTitlePanelFlat(point: IPoint, controller: DocController, text: string | LocalizableString): Promise<IPdfBrick>;
    static createDescFlat(point: IPoint, question: IQuestion, controller: DocController, text: string | LocalizableString): Promise<IPdfBrick>;
    static getReadonlyRenderAs(question: Question, controller: DocController): 'auto' | 'text' | 'acroform';
    static createCommentFlat(point: IPoint, question: Question, controller: DocController, rows: number, isQuestion: boolean, index?: number): Promise<IPdfBrick>;
    static getQuestionOrCommentValue(question: Question, isQuestion?: boolean): string;
    static createImageFlat(point: IPoint, question: IQuestion, controller: DocController, imagelink: string, width: number, height?: number): IPdfBrick;
    static canPreviewImage(question: QuestionFileModel, item: {
        name: string;
        type: string;
        content: string;
    }, url: string): Promise<boolean>;
    static getImageSize(url: string): Promise<ISize>;
    static createRowlineFlat(point: IPoint, controller: DocController, width?: number, color?: string): IPdfBrick;
    static createLinkFlat(point: IPoint, question: Question, controller: DocController, text: string, link: string): Promise<IPdfBrick>;
    static createAcroformRect(rect: IRect): number[];
    static createTextFieldRect(point: IPoint, controller: DocController, lines?: number): IRect;
    static createReadOnlyTextFieldTextFlat(point: IPoint, controller: DocController, question: Question, value: string, onlyFirstLine: boolean): Promise<IPdfBrick>;
    static renderFlatBorders(controller: DocController, flat: PdfBrick): void;
    static renderReadOnlyTextField(controller: DocController, question: Question, flat: PdfBrick, value: string, onlyFirstLine?: boolean): Promise<void>;
    static getLocString(text: LocalizableString): string;
    static getContentQuestion(question: Question): Question;
    static getRatingMinWidth(controller: DocController): number;
    static getRatingItemText(question: QuestionRatingModel, index: number, locText: LocalizableString): LocalizableString;
    static getPageAvailableWidth(controller: DocController): number;
    static getImagePickerAvailableWidth(controller: DocController): number;
    static getColumnWidth(controller: DocController, colCount: number): number;
    static setColumnMargins(controller: DocController, colCount: number, column: number): void;
    static moveRect(rect: IRect, left?: number, top?: number): IRect;
    static scaleRect(rect: IRect, scale: number): IRect;
    static formScale(controller: DocController, flat: PdfBrick): number;
    static generateQuestionFlats(survey: SurveyPDF, controller: DocController, question: Question, point: IPoint): Promise<IPdfBrick[]>;
    static isCustomFont(controller: DocController, fontName: string): boolean;
    static fixFont(controller: DocController): void;
    static clone(src: any): any;
}

import './jspdf_plugins/acroform.js';
import './jspdf_plugins/from_html.js';
export interface IPoint {
    xLeft: number;
    yTop: number;
}
export interface IRect extends IPoint {
    xRight: number;
    yBot: number;
}
export interface ISize {
    width: number;
    height: number;
}
export interface IMarginLR {
    left?: number;
    right?: number;
}
export interface IMargin extends IMarginLR {
    top?: number;
    bot?: number;
}
export interface IDocOptions {
    orientation?: 'p' | 'l';
    format?: string | number[];
    fontSize?: number;
    fontName?: string;
    base64Normal?: string;
    base64Bold?: string;
    margins?: IMargin;
    commercial?: boolean;
    haveCommercialLicense?: boolean;
    htmlRenderAs?: 'auto' | 'standard' | 'image';
    matrixRenderAs?: 'auto' | 'list';
    readonlyRenderAs?: 'auto' | 'text' | 'acroform';
    compress?: boolean;
}
export declare class DocOptions implements IDocOptions {
    static readonly MM_TO_PT: number;
    static readonly FONT_SIZE = 14;
    protected _fontSize: number;
    protected _margins: IMargin;
    protected _format: string | number[];
    protected _orientation: 'l' | 'p';
    protected _fontName: string;
    protected _htmlRenderAs: 'auto' | 'standard' | 'image';
    protected _matrixRenderAs: 'auto' | 'list';
    protected _readonlyRenderAs: 'auto' | 'text' | 'acroform';
    protected _compress: boolean;
    constructor(options: IDocOptions);
    get leftTopPoint(): IPoint;
    get fontName(): string;
    get fontSize(): number;
    get margins(): IMargin;
    get format(): string | number[];
    get orientation(): 'l' | 'p';
    get htmlRenderAs(): 'auto' | 'standard' | 'image';
    get matrixRenderAs(): 'auto' | 'list';
    get readonlyRenderAs(): 'auto' | 'text' | 'acroform';
    get compress(): boolean;
}
export declare class DocController extends DocOptions {
    constructor(options?: IDocOptions);
    get doc(): any;
    get helperDoc(): any;
    get fontName(): string;
    get fontSize(): number;
    get fontStyle(): string;
    set fontName(fontName: string);
    set fontSize(fontSize: number);
    set fontStyle(fontStyle: string);
    measureText(text?: string | LocalizableString | number, fontStyle?: string, fontSize?: number): ISize;
    get unitWidth(): number;
    get unitHeight(): number;
    pushMargins(left?: number, right?: number): void;
    popMargins(): void;
    get paperWidth(): number;
    get paperHeight(): number;
    getNumberOfPages(): number;
    addPage(): void;
    setPage(index: number): void;
}

export declare type FlatConstructor = new (survey: SurveyPDF, question: IQuestion, controller: DocController) => IFlatQuestion;
export declare class FlatRepository {
    static getInstance(): FlatRepository;
    register(modelType: string, rendererConstructor: FlatConstructor): void;
    create(survey: SurveyPDF, question: IQuestion, docController: DocController, type?: string): IFlatQuestion;
}

export interface IFlatQuestion {
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
    generateFlats(point: IPoint): Promise<IPdfBrick[]>;
}
export declare class FlatQuestion implements IFlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    static readonly CONTENT_GAP_VERT_SCALE: number;
    static readonly CONTENT_GAP_HOR_SCALE: number;
    static readonly DESC_GAP_SCALE: number;
    protected question: Question;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsComposite(point: IPoint): Promise<IPdfBrick[]>;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
    generateFlats(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatBoolean extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionBooleanModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatCheckbox extends FlatSelectBase {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionCheckboxModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatItem(rect: IRect, item: ItemValue, index: number): IPdfBrick;
}

export declare class FlatComment extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionCommentModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatDropdown extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionDropdownModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatExpression extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionExpressionModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatFile extends FlatQuestion {
    protected survey: SurveyPDF;
    static readonly IMAGE_GAP_SCALE: number;
    static readonly TEXT_MIN_SCALE: number;
    protected question: QuestionFileModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatHTML extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionHtmlModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatImage extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionImageModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatImagePicker extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionImagePickerModel;
    protected radio: FlatRadiogroup;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatPanelDynamic extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionPanelDynamicModel;
    static readonly GAP_BETWEEN_PANELS: number;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatRadiogroup extends FlatSelectBase {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionRadiogroupModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatItem(rect: IRect, item: ItemValue, index: number, key?: string, checked?: boolean): IPdfBrick;
}

export declare class FlatRating extends FlatRadiogroup {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected questionRating: QuestionRatingModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected generateFlatHorisontalComposite(point: IPoint, item: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateFlatComposite(point: IPoint, item: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateHorisontallyItems(point: IPoint): Promise<CompositeBrick[]>;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare abstract class FlatSelectBase extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected question: QuestionCheckboxBase;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    abstract generateFlatItem(rect: IRect, item: ItemValue, index: number): IPdfBrick;
    protected generateFlatComposite(point: IPoint, item: ItemValue, index: number): Promise<IPdfBrick>;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
    protected generateVerticallyItems(point: IPoint, itemValues: ItemValue[]): Promise<IPdfBrick[]>;
    protected generateHorisontallyItems(point: IPoint, colCount: number): Promise<IPdfBrick[]>;
}

export declare class FlatSignaturePad extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionSignaturePadModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatTextbox extends FlatQuestion {
    protected survey: SurveyPDF;
    protected question: QuestionTextModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatSurvey {
    static readonly QUES_GAP_VERT_SCALE: number;
    static readonly PANEL_CONT_GAP_SCALE: number;
    static readonly PANEL_DESC_GAP_SCALE: number;
    static generateFlatsPanel(survey: SurveyPDF, controller: DocController, panel: PanelModel, point: IPoint): Promise<IPdfBrick[]>;
    static generateFlats(survey: SurveyPDF, controller: DocController): Promise<IPdfBrick[][]>;
}

export declare class FlatMatrix extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    static readonly GAP_BETWEEN_ROWS: number;
    protected question: QuestionMatrixModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    protected generateFlatsHeader(point: IPoint): Promise<IPdfBrick[]>;
    protected generateFlatsRows(point: IPoint, isVertical: boolean): Promise<IPdfBrick[]>;
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}
export declare class FlatMatrixRow extends FlatRadiogroup {
    protected survey: SurveyPDF;
    protected controller: DocController;
    protected isFirst: boolean;
    protected isVertical: boolean;
    protected questionMatrix: QuestionMatrixModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController, row: MatrixRowModel, key: string, isFirst?: boolean, isVertical?: boolean);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
    protected generateTextComposite(point: IPoint, column: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateItemCompoiste(point: IPoint, column: ItemValue, index: number): Promise<IPdfBrick>;
    protected generateFlatsHorizontallyCells(point: IPoint): Promise<IPdfBrick[]>;
    protected generateFlatsVerticallyCells(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatMatrixMultiple extends FlatQuestion {
    protected survey: SurveyPDF;
    protected isMultiple: boolean;
    static readonly GAP_BETWEEN_ROWS: number;
    protected question: QuestionMatrixDropdownModelBase;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController, isMultiple?: boolean);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class FlatMatrixDynamic extends FlatMatrixMultiple {
    protected survey: SurveyPDF;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
}

export declare class FlatMultipleText extends FlatQuestion {
    protected survey: SurveyPDF;
    protected controller: DocController;
    static readonly ROWS_GAP_SCALE: number;
    protected question: QuestionMultipleTextModel;
    constructor(survey: SurveyPDF, question: IQuestion, controller: DocController);
    generateFlatsContent(point: IPoint): Promise<IPdfBrick[]>;
}

export declare class PagePacker {
    static pack(flats: IPdfBrick[][], controller: DocController): IPdfBrick[][];
}

export declare class EventAsync<T extends Function, Options> extends Event<T, Options> {
    unshift(func: T): void;
    fire(sender: any, options: Options): Promise<void>;
}
export declare class EventHandler {
    static process_header_events(survey: SurveyPDF, controller: DocController, packs: IPdfBrick[][]): void;
}

/**
    * Horizontal alignment types in onRenderHeader and onRenderFooter events
    */
export declare enum HorizontalAlign {
        NotSet = "notset",
        Left = "left",
        Center = "center",
        Right = "right"
}
/**
    * Vertical alignment types in onRenderHeader and onRenderFooter events
    */
export declare enum VerticalAlign {
        NotSet = "notset",
        Top = "top",
        Middle = "middle",
        Bottom = "bottom"
}
/**
    * Common options of rendering text and images in onRenderHeader and onRenderFooter events
    */
export interface IDrawRectOptions {
        /**
            * Specifies horizontal alignment of item, if set (center by default)
            */
        horizontalAlign?: HorizontalAlign;
        /**
            * Specifies vertical alignment of item, if set (middle by default)
            */
        verticalAlign?: VerticalAlign;
        /**
            * Specifies margins inside the drawing rectangle (used if alignment set, all zero by default)
            */
        margins?: IMargin;
        /**
            * Object with coordinates of text rectangle (used if alignment not set)
            */
        rect?: IRect;
}
/**
    * Options of rendering text in onRenderHeader and onRenderFooter events
    */
export interface IDrawTextOptions extends IDrawRectOptions {
        /**
            * String that will be drawn
            */
        text: string;
        /**
            * Font size of text (14 by default)
            */
        fontSize?: number;
        /**
            * Set true to make text bold (false by default)
            */
        isBold?: boolean;
}
/**
    * Options of rendering images in onRenderHeader and onRenderFooter events
    */
export interface IDrawImageOptions extends IDrawRectOptions {
        /**
            * Specifies image width (used if alignment set, canvas.rect's width by default)
            */
        width?: number;
        /**
            * Specifies image height (used if alignment set, canvas.rect's height by default)
            */
        height?: number;
        /**
            * String with base64 encoded image
            */
        base64: string;
}
/**
    * DrawCanvas object passed to onRenderHeader and onRenderFooter events
    */
export declare class DrawCanvas {
        protected packs: IPdfBrick[];
        protected controller: DocController;
        protected _rect: IRect;
        protected _countPages: number;
        protected _pageNumber: number;
        constructor(packs: IPdfBrick[], controller: DocController, _rect: IRect, _countPages: number, _pageNumber: number);
        /**
            * Count of pages in the document
            */
        get countPages(): number;
        /**
            * Page number from 1
            */
        get pageNumber(): number;
        /**
            * Object with coordinates of the rectangle available for drawing
            * @see IRect
            */
        get rect(): IRect;
        /**
            * Call this method to draw text
            * @param textOptions Set options of the drawn text
            */
        drawText(textOptions: IDrawTextOptions): void;
        /**
            * Call this method to draw image
            * @param imageOptions
            */
        drawImage(imageOptions: IDrawImageOptions): void;
}

export interface IPdfBrick extends IRect, ISize {
    render(): Promise<void>;
    unfold(): IPdfBrick[];
    isPageBreak: boolean;
}
export declare class PdfBrick implements IPdfBrick {
    protected question: IQuestion;
    protected controller: DocController;
    xLeft: number;
    xRight: number;
    yTop: number;
    yBot: number;
    /**
      * Size of text. Set 0 for auto size
      */
    fontSize: number;
    textColor: string;
    formBorderColor: string;
    isPageBreak: boolean;
    constructor(question: IQuestion, controller: DocController, rect: IRect);
    get width(): number;
    get height(): number;
    render(): Promise<void>;
    renderInteractive(): Promise<void>;
    renderReadOnly(): Promise<void>;
    unfold(): IPdfBrick[];
}

export declare class BooleanItemBrick extends CheckItemBrick {
    constructor(question: IQuestion, controller: DocController, rect: IRect);
}

export declare class CheckboxItemBrick extends CheckItemBrick {
    constructor(question: IQuestion, controller: DocController, rect: IRect, item: ItemValue, index: number);
}

export declare class CheckItemBrick extends PdfBrick {
    protected fieldName: string;
    protected readonly: boolean;
    protected checked: boolean;
    protected question: QuestionCheckboxModel;
    constructor(question: IQuestion, controller: DocController, rect: IRect, fieldName: string, readonly: boolean, checked: boolean);
    renderInteractive(): Promise<void>;
    renderReadOnly(): Promise<void>;
}

export declare class CommentBrick extends TextBoxBrick {
    protected controller: DocController;
    constructor(question: IQuestion, controller: DocController, rect: IRect, isQuestion: boolean, index?: number);
}

export declare class CompositeBrick implements IPdfBrick {
    isPageBreak: boolean;
    constructor(...bricks: IPdfBrick[]);
    get xLeft(): number;
    get xRight(): number;
    get yTop(): number;
    get yBot(): number;
    set xLeft(xLeft: number);
    set xRight(xRight: number);
    set yTop(yTop: number);
    set yBot(yBot: number);
    get width(): number;
    get height(): number;
    render(): Promise<void>;
    get isEmpty(): boolean;
    addBrick(...bricks: IPdfBrick[]): void;
    unfold(): IPdfBrick[];
}

export declare class DropdownBrick extends PdfBrick {
    protected controller: DocController;
    protected question: QuestionDropdownModel;
    protected isQuestion: boolean;
    protected isMultiline: boolean;
    constructor(question: IQuestion, controller: DocController, rect: IRect);
    renderInteractive(): Promise<void>;
    renderReadOnly(): Promise<void>;
}

export declare class HTMLBrick extends PdfBrick {
    protected html: string;
    constructor(question: IQuestion, controller: DocController, rect: IRect, html: string, isImage?: boolean);
    renderInteractive(): Promise<void>;
}

export declare class LinkBrick extends TextBrick {
    protected link: string;
    static readonly COLOR: string;
    constructor(textFlat: TextBrick, link: string);
    renderInteractive(): Promise<void>;
    renderReadOnly(): Promise<void>;
}

export declare class MultipleTextBoxBrick extends TextFieldBrick {
    constructor(question: IQuestion, controller: DocController, rect: IRect, row_index: number, col_index: number, item: MultipleTextItemModel);
}

export declare class RadioGroupWrap {
    name: string;
    constructor(name: string, controller: DocController, _readOnly: boolean);
    addToPdf(color: string): void;
    get radioGroup(): any;
    get readOnly(): boolean;
}
export declare class RadioItemBrick extends PdfBrick {
    constructor(question: IQuestion, controller: DocController, rect: IRect, index: number, checked: boolean, radioGroupWrap: RadioGroupWrap);
    renderInteractive(): Promise<void>;
    renderReadOnly(): Promise<void>;
}

export declare class RowlineBrick implements IPdfBrick {
    protected controller: DocController;
    protected color: string;
    xLeft: number;
    xRight: number;
    yTop: number;
    yBot: number;
    isPageBreak: boolean;
    constructor(controller: DocController, rect: IRect, color: string);
    get width(): number;
    get height(): number;
    render(): Promise<void>;
    unfold(): IPdfBrick[];
}

export declare class TextFieldBrick extends PdfBrick {
    protected isQuestion: boolean;
    protected fieldName: string;
    protected value: string;
    protected placeholder: string;
    protected isReadOnly: boolean;
    protected isMultiline: boolean;
    protected inputType: string;
    protected question: QuestionTextModel;
    constructor(question: IQuestion, controller: DocController, rect: IRect, isQuestion: boolean, fieldName: string, value: string, placeholder: string, isReadOnly: boolean, isMultiline: boolean, inputType: string);
    renderInteractive(): Promise<void>;
    renderReadOnly(): Promise<void>;
}

export declare class TextBoldBrick extends TextBrick {
    constructor(question: IQuestion, controller: DocController, rect: IRect, text: string);
    renderInteractive(): Promise<void>;
}

export declare class TextBoxBrick extends TextFieldBrick {
    protected isQuestion: boolean;
    protected isMultiline: boolean;
    constructor(question: IQuestion, controller: DocController, rect: IRect, isQuestion?: boolean, isMultiline?: boolean, index?: number);
}

export declare class TextBrick extends PdfBrick {
    protected text: string;
    protected align: {
        align: string;
        baseline: string;
    };
    constructor(question: IQuestion, controller: DocController, rect: IRect, text: string);
    renderInteractive(): Promise<void>;
    protected alignPoint(rect: IRect): IPoint;
}

export declare class TitlePanelBrick extends TextBoldBrick {
    protected question: QuestionTextModel;
    constructor(question: IQuestion, controller: DocController, rect: IRect, text: string);
    renderInteractive(): Promise<void>;
}

export declare class AdornersBaseOptions {
    point: IPoint;
    bricks: IPdfBrick[];
    controller: DocController;
    repository: FlatRepository;
    module: any;
    constructor(point: IPoint, bricks: IPdfBrick[], controller: DocController, repository: FlatRepository, module: any);
}
export declare class AdornersOptions extends AdornersBaseOptions {
    question: IQuestion;
    constructor(point: IPoint, bricks: IPdfBrick[], question: IQuestion, controller: DocController, repository: FlatRepository, module: any);
}
export declare class AdornersPanelOptions extends AdornersBaseOptions {
    panel: PanelModel;
    constructor(point: IPoint, bricks: IPdfBrick[], panel: PanelModel, controller: DocController, repository: FlatRepository, module: any);
}
export declare class AdornersPageOptions extends AdornersBaseOptions {
    page: PageModel;
    constructor(point: IPoint, bricks: IPdfBrick[], page: PageModel, controller: DocController, repository: FlatRepository, module: any);
}


